<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>TypeORM - DataMapper ORM for TypeScript and Node.JS</title>

    <link rel="stylesheet" href="stylesheets/github-light.css">
    <link rel="stylesheet" href="vendors/prism/prism.css">
    <link rel="stylesheet" href="vendors/prism/prism-coy.css">
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel="stylesheet">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1><a href="index.html"><strong>Type</strong>ORM</a></h1>
        <p>Data-Mapper ORM for TypeScript, ES7, ES6, ES5. Supports MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle databases.</p>

        <ul class="menu">
            <li><a href="index.html#what-is-typeorm">What is TypeORM?</a><br/></li>
            <li class="no-bullet">
                <ul>
                    <li><a href="index.html#installation">Installation</a><br/></li>
                    <li><a href="index.html#quick-start">Quick Start</a><br/></li>
                </ul>
            </li>
            <li><a href="connection.html">Connection and connection options</a><br/></li>             <li><a href="connection-manager.html">Connection Manager</a><br/></li>
            <li><a href="databases-and-drivers.html">Databases and drivers</a><br/></li>
            <li><a href="updating-database-schema.html">Updating database schema</a><br/></li>
            <li><a href="tables-and-columns.html">Tables and columns</a><br/></li>
            <li><a href="relations.html">Relations</a><br/></li>
            <li><a href="indices.html">Indices</a><br/></li>
            <li><a href="repository.html">Repository</a><br/></li>
            <li><a href="query-builder.html">Query Builder</a><br/></li>
            <li><a href="entity-manager.html">Entity Manager</a><br/></li>
            <li><a href="subscribers-and-entity-listeners.html">Subscribers and entity listeners</a><br/></li>   <li><a href="using-service-container.html">Using service container</a><br/></li>
            <!-- <li><a href="naming-strategies.html">Naming Strategies</a><br/></li> -->
            <li><a href="decorators-reference.html">Decorators Reference</a><br/></li>
        </ul>

    </header>
    <section>
        <h2 id="what-is-typeorm">
            <a class="anchor" href="#what-is-typeorm"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            What is TypeORM?
        </h2>
        <p>
            TypeORM is an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">Object Relational Mapper</a>
            (ORM) for node.js written in
            Typescript that can be used with Typescript or Javascript (ES5, ES6, ES7).
            Its goal to always support latest Javascript features and provide features
            that help you to develop any kind of applications that use database - from
            small applications with a few tables to large scale enterprise applications.
        </p>

        <p>TypeORM helps you to:</p>
        <ul>
            <li>automatically create in the database table schemas based on your models</li>
            <li>ability to transparently insert / update / delete to the database your objects</li>
            <li>map your selections from tables to javascript objects and map table columns
                to javascript object's properties</li>
            <li>easily create one-to-one, many-to-one, one-to-many and many-to-many relations between tables</li>
            <li>and much more...</li>
        </ul>

        <p>
            TypeORM uses <a href="https://en.wikipedia.org/wiki/Data_mapper_pattern">data mapper pattern</a>,
            unlike all other javascript ORMs that currently exist, which means you can write loosely coupled, scalable,
            maintainable applications with less problems.
        </p>

        <p>
        The benefit of using ORM for the programmer is the ability to focus on
        the business logic and don't worry about persistence so much.
        </p>

        <p>
            TypeORM is highly influenced by other ORMs, such as <a href="http://hibernate.org/orm/">Hibernate</a> and
            <a href="http://www.doctrine-project.org/">Doctrine</a>.
        </p>

        <h3 id="installation">
            <a class="anchor" href="#installation"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Installation
        </h3>

        <ol>
            <li>
                <p>Install module via npm:</p>
                <code>npm install typeorm --save</code>
            </li>
            <li>
                <p>You also need to install <a href="https://github.com/rbuckton/ReflectDecorators">reflect-metadata</a> shim:</p>
                <code>npm install reflect-metadata --save</code>
                <p>and use it somewhere in the global place of your app (for example in <i>app.ts</i>):</p>
                <code>import "reflect-metadata";</code>
            </li>
            <!--<li>
                <p>ES6 features are used, if you are using older versions of node.js you may need to install
                    <a href="https://github.com/paulmillr/es6-shim">es6-shim</a>:</p>
                <code>npm install es6-shim &#45;&#45;save</code>
                <p>and use it somewhere in the global place of your app (for example in <i>app.ts</i>):</p>
                <code>import "es6-shim";</code>
            </li>-->
            <li>
                <p>Install database driver:</p>
                <ul>
                    <li>
                        <p>for <b>MySQL</b> or <b>MariaDB</b></p>
                        <code>npm install mysql --save</code>
                    </li>
                    <li>
                        <p>for <b>Postgres</b></p>
                        <code>npm install pg --save</code>
                    </li>
                    <li>
                        <p>for <b>SQLite</b></p>
                        <code>npm install sqlite3 --save</code>
                    </li>
                    <li>
                        <p>for <b>Microsoft SQL Server</b></p>
                        <code>npm install mssql --save</code>
                    </li>
                    <li>
                        <p>for <b>Oracle</b></p>
                        <code>npm install oracledb --save</code>
                    </li>
                </ul>
                <p>Install only one of them, depend on which database you use.</p>
            </li>
        </ol>

        <h5>TypeScript configuration</h5>

        <p>
            Also make sure you are using TypeScript compiler version > <b>2.1</b> and you have enabled following settings in <b>tsconfig.json</b>:
        </p>

        <pre><code class="language-json">
"emitDecoratorMetadata": true,
"experimentalDecorators": true,
        </code></pre>

        <h5>Node.js version</h5>

        <p>
            TypeORM was checked with Node.JS version 6 and above.
            If you have errors during app bootstrap, try to upgrade your node.js version to the latest version.
        </p>

        <h3 id="quick-start">
            <a class="anchor" href="#quick-start"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Quick Start
        </h3>

        <p>
            In TypeORM tables are created from Entities.
            <i>Entity</i> is your model decorated by a <code>@Table</code> decorator.
            You can get entities from the database and insert/update/remove them from there.
            Let's say we have a model <code>entity/Photo.ts</code>:
        </p>

        <pre><code class="language-typescript">
export class Photo {
    id: number;
    name: string;
    description: string;
    fileName: string;
    views: number;
}
        </code></pre>

        <h4 id="example-create-entity">
            <a class="anchor" href="#example-create-entity"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Creating entity
        </h4>
        <p>
            Now lets make it entity:
        </p>

        <pre><code class="language-typescript">
import {Table} from "typeorm";

@Table()
export class Photo {
    id: number;
    name: string;
    description: string;
    fileName: string;
    views: number;
    isPublished: boolean;
}
        </code></pre>

        <h4 id="example-create-columns">
            <a class="anchor" href="#example-create-columns"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Add table columns
        </h4>

        <p>
            Now we have a table, and each table consist of columns. Let's add some columns.
            You can make any property of your model a column by using a <code>@Column</code> decorator:
        </p>

        <pre><code class="language-typescript">
import {Table, Column} from "typeorm";

@Table()
export class Photo {

    @Column()
    id: number;

    @Column()
    name: string;

    @Column()
    description: string;

    @Column()
    fileName: string;

    @Column()
    views: number;

    @Column()
    isPublished: boolean;
}
        </code></pre>

        <h4 id="example-primary-column">
            <a class="anchor" href="#example-primary-column"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Create a primary column
        </h4>

        <p>
            Perfect. Now ORM will generate us a photo table with all its properties as columns.
            But there is one thing left. Each entity must have a primary column.
            This is requirement and you can't avoid it. To make a column a primary you need to use <code>@PrimaryColumn</code>
            decorator.
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryColumn} from "typeorm";

@Table()
export class Photo {

    @PrimaryColumn()
    id: number;

    @Column()
    name: string;

    @Column()
    description: string;

    @Column()
    fileName: string;

    @Column()
    views: number;

    @Column()
    isPublished: boolean;
}
        </code></pre>

        <h4 id="example-auto-increment">
            <a class="anchor" href="#example-auto-increment"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Create auto-increment / generated / sequence / identity column
        </h4>

        <p>
            Now, lets say you want to make your id column to be auto-generated
            (this is known as auto-increment / sequence / generated identity column).
            To do that you need to change your column's type to <code>integer</code> and set a
            <code>{ generated: true }</code> in your primary column's options:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryColumn} from "typeorm";

@Table()
export class Photo {

    @PrimaryColumn("int", { generated: true })
    id: number;

    @Column()
    name: string;

    @Column()
    description: string;

    @Column()
    fileName: string;

    @Column()
    views: number;

    @Column()
    isPublished: boolean;
}
        </code></pre>

        <h4 id="example-primary-generated-column">
            <a class="anchor" href="#example-primary-generated-column"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Using @PrimaryGeneratedColumn decorator
        </h4>

        <p>
            Now your photo's id will always be a generated, auto increment value.
            Since this is a common task - to create a generated auto increment primary column,
            there is a special decorator called <code>@PrimaryGeneratedColumn</code> to do the same.
            Let's use it instead:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn} from "typeorm";

@Table()
export class Photo {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @Column()
    description: string;

    @Column()
    fileName: string;

    @Column()
    views: number;

    @Column()
    isPublished: boolean;
}
        </code></pre>

        <h4 id="example-column-data-types">
            <a class="anchor" href="#example-column-data-types"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Custom column data types
        </h4>

        <p>
            Next step, lets fix our data types.
            By default, string is mapped to a varchar(255)-like type (depend of database type).
            Number is mapped to a float/double-like type (depend of database type).
            We don't want all our columns to be limited varchars or excessive floats.
            Lets setup correct data types:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn} from "typeorm";

@Table()
export class Photo {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 500
    })
    name: string;

    @Column("text")
    description: string;

    @Column()
    fileName: string;

    @Column("int")
    views: number;

    @Column()
    isPublished: boolean;
}
        </code></pre>

        <h4 id="example-create-connection">
            <a class="anchor" href="#example-create-connection"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Creating connection with the database
        </h4>

        <p>
            Now, when our entity is created, lets create <code>app.ts</code> file and setup our connection there:
        </p>

        <pre><code class="language-typescript">
import "reflect-metadata";
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection({
    driver: {
        type: "mysql",
        host: "localhost",
        port: 3306,
        username: "root",
        password: "admin",
        database: "test"
    },
    entities: [
        Photo
    ],
    autoSchemaSync: true,
}).then(connection => {
    // here you can start to work with your entities
}).catch(error => console.log(error));
        </code></pre>

        <p>
            We are using mysql in this example, but you can use any other database.
            To use another database simply change <code>type</code> in the driver options
            to the database type you are using: <b>mysql, mariadb, postgres, sqlite, mssql</b> or <b>oracle</b>.
            Also make sure to use your own host, port, username, password and database settings.
        </p>

        <p>
            We added our <code>Photo</code> entity to the list of entities for this connection.
            Each entity you are using in your connection must be listed here.
        </p>

        <p>
            Setting <code>autoSchemaSync</code> makes sure your entities will be synced with the database,
            every time you run the application.
        </p>

        <h4 id="example-entity-directories">
            <a class="anchor" href="#example-entity-directories"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Loading all entities from the directory
        </h4>

        <p>
            Later, when we create more entities we need to add them to the <code>entities</code> in our configuration.
            But this is not very convenient, and instead we can setup the whole directory, where from all entities
            will be connected and used in our connection:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";

createConnection({
    driver: {
        type: "mysql",
        host: "localhost",
        port: 3306,
        username: "root",
        password: "admin",
        database: "test"
    },
    entities: [
        __dirname + "/entity/*.js"
    ],
    autoSchemaSync: true,
}).then(connection => {
    // here you can start to work with your entities
}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-run">
            <a class="anchor" href="#example-run"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Run the application
        </h4>

        <p>
            Now you if run your <code>app.ts</code>, connection with database will be initialized and database
            table for your <code>Photo</code> will be created.
        </p>

        <pre><code class="language-typescript">
+-------------+--------------+----------------------------+
|                         photo                           |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| name        | varchar(500) |                            |
| description | text         |                            |
| filename    | varchar(255) |                            |
| views       | int(11)      |                            |
| isPublished | boolean      |                            |
+-------------+--------------+----------------------------+
        </code></pre>

        <p>
            Now you can run your <code>app.ts</code>, connection with database will be initialized, and database
            table for your <code>Photo</code> will be created.
        </p>

        <h4 id="example-persist-entity">
            <a class="anchor" href="#example-persist-entity"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Creating and inserting photo into the database
        </h4>

        <p>
            Now lets create a new photo to save it in the database:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";

createConnection(/*...*/).then(connection => {

    let photo = new Photo();
    photo.name = "Me and Bears";
    photo.description = "I am near polar bears";
    photo.filename = "photo-with-bears.jpg";
    photo.views = 1;
    photo.isPublished = true;

    connection.entityManager
            .persist(photo)
            .then(photo => {
                console.log("Photo has been saved");
            });

}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-async-await">
            <a class="anchor" href="#example-async-await"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Using async/await syntax
        </h4>

        <p>
            Lets use latest TypeScript advantages and use async/await syntax instead:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection(/*...*/).then(async connection => {

    let photo = new Photo();
    photo.name = "Me and Bears";
    photo.description = "I am near polar bears";
    photo.filename = "photo-with-bears.jpg";
    photo.views = 1;
    photo.isPublished = true;

    await connection.entityManager.persist(photo);
    console.log("Photo has been saved");

}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-entity-manager">
            <a class="anchor" href="#example-entity-manager"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Using Entity Manager
        </h4>

        <p>
            We just created a new photo and saved it in the database.
            We used <code>EntityManager</code> to save it.
            Using entity managers you can manipulate any entity in your app.
            Now lets load our saved entity:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection(/*...*/).then(async connection => {

    /*...*/
    let savedPhotos = await connection.entityManager.find(Photo);
    console.log("All photos from the db: ", savedPhotos);

}).catch(error => console.log(error));
        </code></pre>

        <p>
            <code>savedPhotos</code> will be an array of Photo objects with the data loaded from the database.
        </p>

        <h4 id="example-repository">
            <a class="anchor" href="#example-repository"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Using Repositories
        </h4>

        <p>
            Now lets refactor our code and use <code>Repository</code> instead of <code>EntityManager</code>.
            Each entity has its own repository which handles all operations with its entity.
            When you deal with entities a lot, Repositories are more convenient to use then EntityManager:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection(/*...*/).then(async connection => {

    let photo = new Photo();
    photo.name = "Me and Bears";
    photo.description = "I am near polar bears";
    photo.filename = "photo-with-bears.jpg";
    photo.views = 1;
    photo.isPublished = true;

    let photoRepository = connection.getRepository(Photo);

    await photoRepository.persist(photo);
    console.log("Photo has been saved");

    let savedPhotos = await photoRepository.find();
    console.log("All photos from the db: ", savedPhotos);

}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-load">
            <a class="anchor" href="#example-load"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Loading photos from the database
        </h4>

        <p>
            Lets try more load operations using Repository:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection(/*...*/).then(async connection => {

    /*...*/
    let allPhotos = await photoRepository.find();
    console.log("All photos from the db: ", allPhotos);

    let firstPhoto = await photoRepository.findOneById(1);
    console.log("First photo from the db: ", firstPhoto);

    let meAndBearsPhoto = await photoRepository.findOne({ name: "Me and Bears" });
    console.log("Me and Bears photo from the db: ", meAndBearsPhoto);

    let allViewedPhotos = await photoRepository.find({ views: 1 });
    console.log("All viewed photos: ", allViewedPhotos);

    let allPublishedPhotos = await photoRepository.find({ isPublished: true });
    console.log("All published photos: ", allPublishedPhotos);

    let [allPhotos, photosCount] = await photoRepository.findAndCount();
    console.log("All photos: ", allPublishedPhotos);
    console.log("Photos count: ", allPublishedPhotos);

}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-update">
            <a class="anchor" href="#example-update"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Updating photo in the database
        </h4>

        <p>
            Now lets load a single photo from the database, update it and save it:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection(/*...*/).then(async connection => {

    /*...*/
    let photoToUpdate = await photoRepository.findOneById(1);
    photoToUpdate.name = "Me, my friends and polar bears";
    await photoRepository.persist(photoToUpdate);

}).catch(error => console.log(error));
        </code></pre>

        <p>
            Now photo with id = 1 will be updated in the database.
        </p>

        <h4 id="example-remove">
            <a class="anchor" href="#example-remove"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Removing photo from the database
        </h4>

        <p>
            Now let's remove our photo from the database:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";

createConnection(/*...*/).then(async connection => {

    /*...*/
    let photoToRemove = await photoRepository.findOneById(1);
    await photoRepository.remove(photoToRemove);

}).catch(error => console.log(error));
        </code></pre>

        <p>
            Now photo with id = 1 will be removed from the database.
        </p>

        <h4 id="example-one-to-one">
            <a class="anchor" href="#example-one-to-one"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            creating a one-to-one relation
        </h4>

        <p>
            Lets create a one-to-one relation with another class.
            Lets create a new class called <code>PhotoMetadata.ts</code> which will contain a <code>PhotoMetadata</code>
            class which supposed to contain our photo's additional meta-information:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn} from "typeorm";
import {Photo} from "./Photo";

@Table()
export class PhotoMetadata {

    @PrimaryGeneratedColumn()
    id: number;

    @Column("int")
    height: number;

    @Column("int")
    width: number;

    @Column()
    orientation: string;

    @Column()
    compressed: boolean;

    @Column()
    comment: string;

    @OneToOne(type => Photo)
    @JoinColumn()
    photo: Photo;
}
        </code></pre>

        <p>
            Here, we are used a new decorator called <code>@OneToOne</code>.
            It allows to create one-to-one relations between two entities.
            <code>type => Photo</code> is a function that returns the class of the entity with which we want to make our relation.
            We are forced to use a function that returns a class, instead of using class directly, because of the language specifics.
            We can also write it as a () => Photo, but we use type => Photo as convention to increase code readability.
            Type variable itself does not contain anything.
        </p>

        <p>
            We also put <code>@JoinColumn</code> decorator, which indicates that this side of the relationship will be owning relationship.
            Relations can be a uni-directional and bi-directional.
            Only one side of relational can be owner.
            Using this decorator is required on owner side of the relationship.
        </p>

        <p>
            If you run the app you'll see a new generated table, and it will contain a column with a foreign key for
            the photo relation:
        </p>

        <pre><code class="language-typescript">
+-------------+--------------+----------------------------+
|                         photo                           |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| height      | int(11)      |                            |
| width       | int(11)      |                            |
| comment     | varchar(255) |                            |
| compressed  | boolean      |                            |
| orientation | varchar(255) |                            |
| photo       | int(11)      | FOREIGN KEY                |
+-------------+--------------+----------------------------+
        </code></pre>

        <h4 id="example-one-to-one-persist">
            <a class="anchor" href="#example-one-to-one-persist"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            persisting an object with one-to-one relation
        </h4>

        <p>
            Now lets save a photo, its metadata and attach them to each other.
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";
import {PhotoMetadata} from "./entity/PhotoMetadata";

createConnection(/*...*/).then(async connection => {

    // create a photo
    let photo = new Photo();
    photo.name = "Me and Bears";
    photo.description = "I am near polar bears";
    photo.filename = "photo-with-bears.jpg"
    photo.isPublished = true;

    // create a photo metadata
    let metadata = new PhotoMetadata();
    metadata.height = 640;
    metadata.width = 480;
    metadata.compressed = true;
    metadata.comment = "cybershoot";
    metadata.orientation = "portait";
    metadata.photo = photo; // this way we connect them

    // get entity repositories
    let photoRepository = connection.getRepository(Photo);
    let metadataRepository = connection.getRepository(PhotoMetadata);

    // first we should persist a photo
    await photoRepository.persist(photo);

    // photo is saved. Now we need to persist a photo metadata
    await metadataRepository.persist(metadata);

    // done
    console.log("metadata is saved, and relation between metadata and photo is created in the database too");

}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-one-to-one-inverse">
            <a class="anchor" href="#example-one-to-one-inverse"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Adding inverse side of a relation
        </h4>

        <p>
            Relations can be a uni-directional and bi-directional.
            Now, relation between <b>PhotoMetadata</b> and <b>Photo</b> is uni-directional.
            Owner of the relation is <b>PhotoMetadata</b> and <b>Photo</b> doesn't know anything
            about <b>PhotoMetadata</b>. This makes complicated accessing a photo metadata from the photo objects.
            To fix it we should add inverse relation and make relations between <b>PhotoMetadata</b> and <b>Photo</b> bi-directional.
            Let's modify our entities:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn, OneToOne, JoinColumn} from "typeorm";
import {Photo} from "./Photo";

@Table()
export class PhotoMetadata {

    /* ... other columns */

    @OneToOne(type => Photo, photo => photo.metadata)
    @JoinColumn()
    photo: Photo;
}
        </code></pre>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn, OneToOne} from "typeorm";
import {PhotoMetadata} from "./PhotoMetadata";

@Table()
export class Photo {

    /* ... other columns */

    @OneToOne(type => PhotoMetadata, photoMetadata => photoMetadata.photo)
    metadata: PhotoMetadata;
}
        </code></pre>

        <p>
            <code>photo => photo.metadata</code> is a function that returns a name of the inverse side of the relation.
            Here we show that metadata property of the Photo class is where we store PhotoMetadata in the Photo class.
            You could also instead of passing function that returns a property of the photo simply pass a string to @OneToOne decorator, like "metadata".
            But we used this function-typed approach to make your refactorings easier.
        </p>

        <p>
            Note that we should use <code>@JoinColumn</code> only on one side of relation.
            On which side you put this decorator, that side will be owning side of relationship.
            Owning side of relationship contain a column with a foreign key in the database.
        </p>

        <h4 id="example-one-to-one-load">
            <a class="anchor" href="#example-one-to-one-load"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Loading object with their relations
        </h4>

        <p>
            Now lets load our photo, and its photo metadata in a single query.
            There are two ways to do it - one you can use <code>FindOptions</code>, second is to use <code>QueryBuilder</code>.
            Lets use <code>FindOptions</code> first.
            <code>Repository.find</code> method allows you to specify object with <code>FindOptions</code> interface.
            Using this you can customize your query to perform more complex queries.
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";
import {PhotoMetadata} from "./entity/PhotoMetadata";

createConnection(/*...*/).then(async connection => {

    /*...*/
    let photoRepository = connection.getRepository(Photo);
    let photos = await photoRepository.find({
        alias: "photo",
        innerJoinAndSelect: {
            "metadata": "photo.metadata"
        }
    });

}).catch(error => console.log(error));
        </code></pre>

        <p>
            Here photos will contain array of photos from the database, and each photo will contain its photo metadata.
        </p>

        <p>
            <b>alias</b> is a required property of FindOptions.
            Its your own alias name of the data you are selecting.
            You'll use this alias in your where, order by, group by, join and other expressions.
        </p>

        <p>
            We also used <b>innerJoinAndSelect</b> to inner and join and select the data from photo.metadata.
            In <b>"photo.metadata"</b> "photo" is an alias you used, and "metadata" is a property name with relation
            of the object you are selecting. <b>"metadata":</b> is a new alias to the data returned by join expression.
        </p>

        <p>
            Lets use <code>QueryBuilder</code> for the same purpose.
            QueryBuilder allows to use more complex queries in an elegant way:
        </p>

        <pre><code class="language-typescript">
import {createConnection} from "typeorm";
import {Photo} from "./entity/Photo";
import {PhotoMetadata} from "./entity/PhotoMetadata";

createConnection(/*...*/).then(async connection => {

    /*...*/
    let photoRepository = connection.getRepository(Photo);
    let photos = await photoRepository.createQueryBuilder("photo")
            .innerJoinAndSelect("photo.metadata")
            .getResults();

}).catch(error => console.log(error));
        </code></pre>

        <h4 id="example-cascades">
            <a class="anchor" href="#example-cascades"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            using cascade options to automatically save related objects
        </h4>

        <p>We can setup cascade options in our relations, in the cases when we want
            our related object to be persisted whenever other object is saved. Let's
            change our photo's @OneToOne decorator a bit:</p>

        <pre><code class="language-typescript">
export class Photo {
    /// ... other columns

    @OneToOne(type => PhotoMetadata, metadata => metadata.photo, {
        cascadeInsert: true,
        cascadeUpdate: true,
        cascadeRemove: true
    })
    metadata: PhotoMetadata;
}
        </code></pre>

        <ul>
            <li><b>cascadeInsert</b> - automatically insert metadata in the relation if
                it does not exist in its table. This means that we don't need to manually
                insert a newly created photoMetadata object.</li>
            <li><b>cascadeUpdate</b> - automatically update metadata in the relation if
                in this object something is changed</li>
            <li><b>cascadeRemove</b> - automatically remove metadata from its table if you
                removed metadata from photo object</li>
        </ul>

        <p>Using <b>cascadeInsert</b> allows us not to separately persist photo and
            separately persist metadata objects now. Now we can simply persist a
            photo object, and metadata object will persist automatically because of
            cascade options.</p>

        <pre><code class="language-typescript">
createConnection(options).then(async connection => {

    // create photo object
    let photo = new Photo();
    photo.name = "Me and Bears";
    photo.description = "I am near polar bears";
    photo.filename = "photo-with-bears.jpg"
    photo.isPublished = true;

    // create photo metadata object
    let metadata = new PhotoMetadata();
    metadata.height = 640;
    metadata.width = 480;
    metadata.compressed = true;
    metadata.comment = "cybershoot";
    metadata.orientation = "portait";
    metadata.photo = photo; // this way we connect them

    // get repository
    let photoRepository = connection.getRepository(Photo);

    // first we should persist a photo
    await photoRepository.persist(photo);

    console.log("Photo is saved, photo metadata is saved too.");

}).catch(error => console.log(error));
        </code></pre>


        <h4 id="example-many-to-one">
            <a class="anchor" href="#example-many-to-one"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            creating a many-to-one / one-to-many relation
        </h4>

        <p>
            Lets create a many-to-one / one-to-many relation.
            Lets say a photo has one author, and each author can have many photos.
            First, lets create <code>Author</code> class:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn, OneToMany} from "typeorm";
import {Photo} from "./Photo";

@Table()
export class Author {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @OneToMany(type => Photo, photo => photo.author) // note: we will create author property in the Photo class below
    photos: Photo[];
}
        </code></pre>

        <p>
            Author contains an inverse side of a relationship.
            <code>OneToMany</code> is always an inverse side of relation,
            and it can't exist without <code>ManyToOne</code> of the other side of relationship.
        </p>

        <p>
            Now lets add owner side of relationship into the <code>Photo</code> entity:
        </p>

        <pre><code class="language-typescript">
import {Table, Column, PrimaryGeneratedColumn, ManyToOne} from "typeorm";
import {PhotoMetadata} from "./PhotoMetadata";
import {Author} from "./Author";

@Table()
export class Photo {

    /* ... other columns */

    @ManyToOne(type => Author, author => author.photos)
    author: Author;
}
        </code></pre>

        <p>
            In many-to-one / one-to-many relation, owner side is always many-to-one.
            It means that class which uses <code>@ManyToOne</code> will store id of the related object.
        </p>
        <p>
            After you run application ORM will create author table:
        </p>

        <pre><code class="language-typescript">
+-------------+--------------+----------------------------+
|                          author                         |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| name        | varchar(255) |                            |
+-------------+--------------+----------------------------+
        </code></pre>

        <p>
            It will also modify photo table - add a new column author and create a foreign key for it:
        </p>

        <pre><code class="language-typescript">
+-------------+--------------+----------------------------+
|                         photo                           |
+-------------+--------------+----------------------------+
| id          | int(11)      | PRIMARY KEY AUTO_INCREMENT |
| name        | varchar(255) |                            |
| description | varchar(255) |                            |
| filename    | varchar(255) |                            |
| isPublished | boolean      |                            |
| author      | int(11)      | FOREIGN KEY                |
+-------------+--------------+----------------------------+
        </code></pre>

        <h4 id="example-many-to-many">
            <a class="anchor" href="#example-many-to-many"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            creating a many-to-many relation
        </h4>

        <p>Lets create a many-to-one / many-to-many relation. Lets say a photo can
        be in many albums, and multiple can have many photos. Lets create an
        `Album` class:</p>

        <pre><code class="language-typescript">
import {Table, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable} from "typeorm";

@Table()
export class Album {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @ManyToMany(type => Photo, photo => photo.albums, {  // note: we will create "albums" property in the Photo class below
        cascadeInsert: true, // allow to insert a new photo on album save
        cascadeUpdate: true, // allow to update a photo on album save
        cascadeRemove: true  // allow to remove a photo on album remove
    })
    @JoinTable()
    photos: Photo[] = []; // we initialize array for convinience here
}
        </code></pre>

        <p>`@JoinTable` is required to specify that this is owner side of the relationship.</p>

        <p>Now lets add inverse side of our relation to the `Photo` class:</p>

        <pre><code class="language-typescript">
export class Photo {
    /// ... other columns

    @ManyToMany(type => Album, album => album.photos, {
        cascadeInsert: true, // allow to insert a new album on photo save
        cascadeUpdate: true, // allow to update an album on photo save
        cascadeRemove: true  // allow to remove an album on photo remove
    })
    albums: Album[] = []; // we initialize array for convinience here
}
        </code></pre>

        <p>After you run application ORM will create a **album_photos_photo_albums**
        *junction table*:</p>

<pre>
+-------------+--------------+----------------------------+
|                album_photos_photo_albums                |
+-------------+--------------+----------------------------+
| album_id_1  | int(11)      | PRIMARY KEY FOREIGN KEY    |
| photo_id_2  | int(11)      | PRIMARY KEY FOREIGN KEY    |
+-------------+--------------+----------------------------+
</pre>


        <p>Don't forget to register `Album` class for your connection in the ORM:</p>

        <pre><code class="language-typescript">
const options: CreateConnectionOptions = {
    // ... other options
    entities: [Photo, PhotoMetadata, Author, Album]
};
        </code></pre>

        <p>Now lets insert author and photo to our database:</p>

        <pre><code class="language-typescript">
let connection = await createConnection(options);

// create a few albums
let album1 = new Album();
album1.name = "Bears";

let album2 = new Album();
album2.name = "Me";

// create a few photos
let photo1 = new Photo();
photo1.name = "Me and Bears";
photo1.description = "I am near polar bears";
photo1.filename = "photo-with-bears.jpg"

let photo2 = new Photo();
photo2.name = "Me and Bears";
photo2.description = "I am near polar bears";
photo2.filename = "photo-with-bears.jpg"

// get entity repository
let photoRepository = connection.getRepository(Photo);

// first save a first photo
// we only save a photos, albums are persisted
// automatically because of cascade options
await photoRepository.persist(photo1);

// second save a first photo
await photoRepository.persist(photo2);

console.log("Both photos have been saved");
</code></pre>

        <h4 id="example-query-builder">
            <a class="anchor" href="#example-query-builder"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            using QueryBuilder
        </h4>

        <p>
            You can use QueryBuilder to build even more complex queries. For example you can do this:
        </p>

        <pre><code class="language-typescript">
let photoRepository = connection.getRepository(Photo);
let photos = await photoRepository
    .createQueryBuilder("photo") // first argument is an alias. Alias is what you are selecting - photos. You must specify it.
    .innerJoinAndSelect("photo.metadata")
    .leftJoinAndSelect("photo.albums")
    .where("photo.isPublished=true")
    .andWhere("(photo.name=:photoName OR photo.name=:bearName)")
    .orderBy("photo.id", "DESC")
    .setFirstResult(5)
    .setMaxResults(10)
    .setParameters({ photoName: "My", bearName: "Mishka" })
    .getResults();
</code></pre>

        <p>
            This query builder will select you all photos that are published and whose name is "My" or "Mishka",
            it will select results from 5 position (pagination offset), and will select only 10 results (pagination limit).
            Selection result will be ordered by id in descending order.
            Photo's albums will be left-joined and photo's metadata will be inner joined.
        </p>
        <p>
            You'll use query builder in your application a lot.
            Learn more about QueryBuilder <a href="query-builder.html">here</a>.
        </p>

        <h3 id="learn-more">
            <a class="anchor" href="#learn-more"><svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>
            Learn More
        </h3>

        <ul class="learn-more">
            <li><a href="connection.html">Connection and connection options</a><br/></li>
            <li><a href="connection-manager.html">Connection Manager</a><br/></li>
            <li><a href="databases-and-drivers.html">Databases and drivers</a><br/></li>
            <li><a href="updating-database-schema.html">Updating database schema</a><br/></li>
            <li><a href="tables-and-columns.html">Tables and columns</a><br/></li>


            <li><a href="relations.html">Relations</a><br/></li>
            <li><a href="indices.html">Indices</a><br/></li>
            <li><a href="repository.html">Repository</a><br/></li>
            <li><a href="query-builder.html">Query Builder</a><br/></li>
            <li><a href="entity-manager.html">Entity Manager</a><br/></li>
            <li><a href="subscribers-and-entity-listeners.html">Subscribers and entity listeners</a><br/></li>   
            <li><a href="using-service-container.html">Using service container</a><br/></li>
            <!-- <li><a href="naming-strategies.html">Naming Strategies</a><br/></li> -->
            <li><a href="decorators-reference.html">Decorators Reference</a><br/></li>
        </ul>

        <p>
            Take a look on samples in <a href="https://github.com/typeorm/typeorm/blob/master/sample">samples</a>
            for more examples of usage.
        </p>

        <a href="https://github.com/typeorm/typeorm"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>

    </section>
    <footer>
        <p>
            <small>
                © 2015-2016 <a href="https://github.com/typeorm/typeorm"><span class="secondary">Type</span>ORM</a>.<br/>
                Created and maintained by <a href="https://github.com/pleerock">Umed Khudoiberdiev</a>.
            </small>
        </p>
    </footer>
</div>

<script src="javascripts/scale.fix.js"></script>
<script src="vendors/prism/prism.js"></script>
<script src="vendors/prism/prism-typescript.min.js"></script>

</body>
</html>
